<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Video Frame Editor</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #1a1a1a;
            color: #e0e0e0;
        }

        .container {
            width: 95%;
            margin: 0;
            background: #2d2d2d;
            border-radius: 0;
            padding: 20px;
            box-shadow: none;
        }

        .video-selector {
            margin-bottom: 20px;
        }

        .current-frame {
            text-align: center;
            margin-bottom: 20px;
        }

        .frame-display {
            position: relative;
            display: inline-block;
            border: 2px solid #555;
            margin-bottom: 10px;
            resize: both;
            overflow: auto;
            min-width: 300px;
            min-height: 200px;
            max-width: 90vw;
            max-height: 80vh;
        }

        .frame-image {
            width: 100%;
            height: 100%;
            display: block;
            object-fit: contain;
        }

        .rectangle {
            position: absolute;
            border: 2px solid #ff6b6b;
            background: rgba(255, 107, 107, 0.2);
            cursor: move;
            min-width: 20px;
            min-height: 20px;
        }

        .rectangle.selected {
            border-color: #ffd700;
            box-shadow: 0 0 8px rgba(255, 215, 0, 0.5);
        }

        .rectangle.previous-frame {
            border-color: #4a90e2;
            background: rgba(74, 144, 226, 0.15);
            border-style: dashed;
            opacity: 0.7;
        }

        .rectangle.previous-frame.selected {
            border-color: #ffd700;
            box-shadow: 0 0 8px rgba(255, 215, 0, 0.5);
            opacity: 1;
        }

        .rectangle.inherited-rectangle {
            border-color: #28a745;
            background: rgba(40, 167, 69, 0.15);
            border-style: solid;
            opacity: 0.8;
        }

        .rectangle.inherited-rectangle.selected {
            border-color: #ffd700;
            box-shadow: 0 0 8px rgba(255, 215, 0, 0.5);
            opacity: 1;
        }

        .rectangle.deleted-rectangle {
            border-color: #666;
            background: rgba(102, 102, 102, 0.1);
            border-style: dashed;
            opacity: 0.4;
        }

        .rectangle.deleted-rectangle.selected {
            border-color: #ffd700;
            box-shadow: 0 0 8px rgba(255, 215, 0, 0.3);
            opacity: 0.7;
        }

        .resize-handle {
            position: absolute;
            background: #ffd700;
            border: 1px solid #ffcc00;
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        .resize-handle.nw {
            top: -4px;
            left: -4px;
            cursor: nw-resize;
        }

        .resize-handle.ne {
            top: -4px;
            right: -4px;
            cursor: ne-resize;
        }

        .resize-handle.sw {
            bottom: -4px;
            left: -4px;
            cursor: sw-resize;
        }

        .resize-handle.se {
            bottom: -4px;
            right: -4px;
            cursor: se-resize;
        }

        .resize-handle.n {
            top: -4px;
            left: 50%;
            transform: translateX(-50%);
            cursor: n-resize;
        }

        .resize-handle.s {
            bottom: -4px;
            left: 50%;
            transform: translateX(-50%);
            cursor: s-resize;
        }

        .resize-handle.w {
            top: 50%;
            left: -4px;
            transform: translateY(-50%);
            cursor: w-resize;
        }

        .resize-handle.e {
            top: 50%;
            right: -4px;
            transform: translateY(-50%);
            cursor: e-resize;
        }

        .rectangle-delete {
            position: absolute;
            top: -8px;
            right: -8px;
            width: 16px;
            height: 16px;
            background: #ff4757;
            border: 1px solid #ff3742;
            border-radius: 50%;
            color: white;
            font-size: 10px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.2s ease;
            z-index: 1000;
            line-height: 1;
        }

        .rectangle:hover .rectangle-delete,
        .rectangle.selected .rectangle-delete {
            opacity: 1;
        }

        .rectangle-delete:hover {
            background: #ff3742;
            transform: scale(1.1);
        }

        .rectangle-delete.inherited {
            background: #ffa726;
            border-color: #ff9800;
        }

        .rectangle-delete.inherited:hover {
            background: #ff9800;
        }

        .rectangle-undelete {
            position: absolute;
            top: -8px;
            right: -8px;
            width: 16px;
            height: 16px;
            background: #52b788;
            border: 1px solid #40916c;
            border-radius: 50%;
            color: white;
            font-size: 10px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.2s ease;
            z-index: 1000;
            line-height: 1;
        }

        .rectangle.deleted-rectangle:hover .rectangle-undelete,
        .rectangle.deleted-rectangle.selected .rectangle-undelete {
            opacity: 1;
        }

        .rectangle-undelete:hover {
            background: #40916c;
            transform: scale(1.1);
        }

        .controls {
            text-align: center;
            margin-bottom: 20px;
        }

        .controls button {
            padding: 10px 20px;
            margin: 0 5px;
            background: #0d7377;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .controls button:hover {
            background: #14a085;
        }

        .video-selector select {
            background: #3d3d3d;
            color: #e0e0e0;
            border: 1px solid #555;
            padding: 8px;
            border-radius: 4px;
        }

        .video-selector label {
            color: #e0e0e0;
            margin-right: 10px;
        }

        .timeline {
            background: #333;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            white-space: nowrap;
        }

        .timeline h3 {
            color: #e0e0e0;
            margin-top: 0;
        }

        .timeline-frames {
            display: inline-flex;
            gap: 5px;
        }

        .timeline-frame {
            border: 2px solid transparent;
            cursor: pointer;
            border-radius: 4px;
            transition: border-color 0.2s;
        }

        .timeline-frame:hover {
            border-color: #14a085;
        }

        .timeline-frame.selected {
            border-color: #ff6b6b;
            border-width: 3px;
        }

        .timeline-frame img {
            width: 100px;
            height: 60px;
            object-fit: cover;
            display: block;
        }
        .timeline-frame .time-display {
            background: rgba(0, 0, 0, 0.7);
            color: #e0e0e0;
            font-size: 10px;
            padding: 2px 4px;
            text-align: center;
            border-radius: 0 0 4px 4px;
            font-family: monospace;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }

        /* Toast Notifications */
        .toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-width: 400px;
        }

        .toast {
            background: #2a2a2a;
            border: 1px solid #555;
            border-radius: 8px;
            padding: 12px 16px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            gap: 10px;
            opacity: 0;
            transform: translateX(100%);
            transition: all 0.3s ease-in-out;
            color: #fff;
            font-size: 14px;
            line-height: 1.4;
            word-wrap: break-word;
        }

        .toast.show {
            opacity: 1;
            transform: translateX(0);
        }

        .toast.success {
            border-color: #52b788;
            background: linear-gradient(135deg, #1b4332 0%, #2d5a3d 100%);
        }

        .toast.success .toast-icon {
            color: #52b788;
        }

        .toast.error {
            border-color: #ff6b6b;
            background: linear-gradient(135deg, #5a1a1a 0%, #6b2a2a 100%);
        }

        .toast.error .toast-icon {
            color: #ff6b6b;
        }

        .toast.warning {
            border-color: #ffa726;
            background: linear-gradient(135deg, #4a3a1a 0%, #5a4a2a 100%);
        }

        .toast.warning .toast-icon {
            color: #ffa726;
        }

        .toast.info {
            border-color: #42a5f5;
            background: linear-gradient(135deg, #1a3a5a 0%, #2a4a6a 100%);
        }

        .toast.info .toast-icon {
            color: #42a5f5;
        }

        .toast-icon {
            font-size: 16px;
            font-weight: bold;
            flex-shrink: 0;
        }

        .toast-message {
            flex: 1;
        }

        .toast-close {
            color: #999;
            cursor: pointer;
            font-size: 18px;
            line-height: 1;
            padding: 0 4px;
            border-radius: 3px;
            transition: color 0.2s ease;
            flex-shrink: 0;
        }

        .toast-close:hover {
            color: #fff;
        }

        /* Legacy status element - keep hidden */
        .status {
            display: none !important;
        }

        /* Export Progress Modal */
        .export-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 20000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .export-modal-content {
            background: #2a2a2a;
            border: 1px solid #555;
            border-radius: 12px;
            padding: 24px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            animation: modalSlideIn 0.3s ease-out;
        }

        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: translateY(-20px) scale(0.95);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        .export-modal h3 {
            color: #e0e0e0;
            margin: 0 0 20px 0;
            text-align: center;
            font-size: 18px;
        }

        .export-progress {
            margin-bottom: 20px;
        }

        .export-step {
            display: flex;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #444;
        }

        .export-step:last-child {
            border-bottom: none;
        }

        .step-icon {
            width: 24px;
            font-size: 14px;
            margin-right: 12px;
        }

        .step-text {
            flex: 1;
            color: #e0e0e0;
            font-size: 14px;
        }

        .step-status {
            font-size: 12px;
            padding: 2px 8px;
            border-radius: 12px;
            min-width: 60px;
            text-align: center;
        }

        .export-step.pending .step-status {
            background: #444;
            color: #999;
        }

        .export-step.active .step-status {
            background: #42a5f5;
            color: white;
        }

        .export-step.active .step-icon {
            color: #42a5f5;
        }

        .export-step.completed .step-status {
            background: #52b788;
            color: white;
        }

        .export-step.completed .step-icon {
            color: #52b788;
        }

        .export-step.error .step-status {
            background: #ff6b6b;
            color: white;
        }

        .export-step.error .step-icon {
            color: #ff6b6b;
        }

        .export-details {
            background: #333;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 20px;
        }

        .detail-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }

        .detail-item:last-child {
            margin-bottom: 0;
        }

        .detail-label {
            color: #999;
            font-size: 13px;
        }

        .detail-value {
            color: #e0e0e0;
            font-size: 13px;
            font-weight: 500;
        }

        .export-progress-bar {
            background: #444;
            border-radius: 10px;
            height: 8px;
            margin-bottom: 20px;
            overflow: hidden;
        }

        .progress-bar-fill {
            background: linear-gradient(90deg, #42a5f5, #52b788);
            height: 100%;
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 10px;
        }

        .cancel-export {
            width: 100%;
            background: #444;
            color: #e0e0e0;
            border: 1px solid #666;
            padding: 10px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s ease;
        }

        .cancel-export:hover {
            background: #555;
        }

        .cancel-export:disabled {
            background: #333;
            color: #666;
            cursor: not-allowed;
        }

        .keyboard-hint {
            text-align: center;
            margin: 10px 0;
            color: #999;
            font-size: 14px;
        }

        h1 {
            color: #e0e0e0;
            text-align: center;
        }

        h3 {
            color: #e0e0e0;
        }

        .size-controls {
            text-align: center;
            margin: 10px 0;
        }

        .size-controls button {
            padding: 5px 10px;
            margin: 0 2px;
            background: #444;
            color: #e0e0e0;
            border: 1px solid #666;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }

        .size-controls button:hover {
            background: #555;
        }

        .size-controls button.active {
            background: #0d7377;
            border-color: #14a085;
        }

        .size-slider {
            margin: 0 10px;
            width: 200px;
        }

        .size-info {
            color: #999;
            font-size: 12px;
            margin-left: 10px;
        }
    </style>
</head>

<body>
    <!-- Toast Container -->
    <div class="toast-container" id="toastContainer"></div>

    <!-- Export Progress Modal -->
    <div class="export-modal" id="exportModal" style="display: none;">
        <div class="export-modal-content">
            <h3>Exporting Video with Blur Effect</h3>
            <div class="export-progress">
                <div class="export-step" id="step1">
                    <span class="step-icon">⏳</span>
                    <span class="step-text">Analyzing video properties...</span>
                    <span class="step-status">pending</span>
                </div>
                <div class="export-step" id="step2">
                    <span class="step-icon">⏳</span>
                    <span class="step-text">Processing frames with blur effect...</span>
                    <span class="step-status">pending</span>
                </div>
                <div class="export-step" id="step3">
                    <span class="step-icon">⏳</span>
                    <span class="step-text">Copying audio track...</span>
                    <span class="step-status">pending</span>
                </div>
                <div class="export-step" id="step4">
                    <span class="step-icon">⏳</span>
                    <span class="step-text">Encoding final video...</span>
                    <span class="step-status">pending</span>
                </div>
            </div>
            <div class="export-details" id="exportDetails">
                <div class="detail-item">
                    <span class="detail-label">Frames with rectangles:</span>
                    <span class="detail-value" id="framesCount">-</span>
                </div>
                <div class="detail-item">
                    <span class="detail-label">Total rectangles:</span>
                    <span class="detail-value" id="rectanglesCount">-</span>
                </div>
                <div class="detail-item">
                    <span class="detail-label">Audio status:</span>
                    <span class="detail-value" id="audioStatus">Checking...</span>
                </div>
                <div class="detail-item">
                    <span class="detail-label">Progress:</span>
                    <span class="detail-value" id="progressText">Starting...</span>
                </div>
            </div>
            <div class="export-progress-bar">
                <div class="progress-bar-fill" id="progressBarFill"></div>
            </div>
            <button class="cancel-export" id="cancelExport" onclick="cancelExport()">Cancel</button>
        </div>
    </div>

    <div class="container">
        <div class="video-selector">
            <label for="videoSelect">Select Video:</label>
            <select id="videoSelect">
                <option value="">Choose a video...</option>
            </select>
            <button onclick="loadVideo()">Load Video</button>
        </div>

        <div class="status" id="status"></div>

        <div class="current-frame" id="currentFrame" style="display: none;">

            <div class="frame-display" id="frameDisplay">
                <img class="frame-image" id="frameImage" src="" alt="Current frame">
            </div>

            <div class="controls">
                <button onclick="clearRectangles()">Clear All Rectangles</button>
                <button onclick="loadExistingRectangles()">Load Rectangles</button>
                <button onclick="saveRectangles()">Save Rectangle Data</button>
                <button onclick="exportBlurred()">Export Video with Blur</button>
                <button onclick="navigateToPreviousChange()">← Previous Change</button>
                <button onclick="navigateToNextChange()">Next Change →</button>
                <span id="frameInfo" style="margin-left: 20px; font-weight: bold;"></span>
                <span id="frameSizeInfo" style="margin-left: 20px; color: #999; font-size: 12px;"></span>
            </div>

            <div class="keyboard-hint">
                Use ← → arrow keys to navigate frames | Ctrl+P/N for prev/next change | Click and drag to add rectangles | Click rectangle to
                select/move | Drag handles to resize | Click × to delete, ↺ to restore | Green = inherited, Grey = deleted
            </div>
        </div>

        <div class="timeline" id="timeline" style="display: none;">
            <h3>Timeline</h3>
            <div class="timeline-frames" id="timelineFrames">
            </div>
        </div>
    </div>

    <script>
        let currentVideo = '';
        let currentFrameIndex = 0;
        let totalFrames = 0;
        let videoFPS = 30; // Default FPS, will be updated when video loads
        let frameRectangles = {}; // Store rectangles per frame - this should persist across frames
        let isDrawing = false;
        let isResizing = false;
        let isDragging = false;
        let startX, startY;
        let currentRect = null;
        let selectedRect = null;
        let resizeHandle = null;
        let dragOffset = { x: 0, y: 0 };
        let imageScale = { x: 1, y: 1, offsetX: 0, offsetY: 0 };

        // Debug: log whenever frameRectangles is modified
        console.log('Initialized frameRectangles:', frameRectangles);

        async function loadVideos() {
            try {
                const response = await fetch('/get_videos');
                const videos = await response.json();
                const select = document.getElementById('videoSelect');

                videos.forEach(video => {
                    const option = document.createElement('option');
                    option.value = video;
                    option.textContent = video;
                    select.appendChild(option);
                });
            } catch (error) {
                showStatus('Error loading videos: ' + error.message, 'error');
            }
        }

        async function loadVideo() {
            const select = document.getElementById('videoSelect');
            currentVideo = select.value;

            if (!currentVideo) {
                showStatus('Please select a video', 'error');
                return;
            }

            showToast('Loading video info and frames...', 'info', 2000);

            try {
                // First get video info to get FPS
                const videoInfoResponse = await fetch(`/get_video_info/${currentVideo}`);
                const videoInfo = await videoInfoResponse.json();
                videoFPS = videoInfo.fps || 30; // Use actual FPS or default to 30
                
                // Then extract frames
                const response = await fetch(`/extract_frames/${currentVideo}`);
                const data = await response.json();
                totalFrames = data.total;

                createTimeline();
                showFrame(0);

                document.getElementById('currentFrame').style.display = 'block';
                document.getElementById('timeline').style.display = 'block';

                // Initialize frame size
                setFrameSize('medium');
                
                // Update frame size display after initial load
                setTimeout(() => {
                    updateFrameSizeDisplay();
                }, 100);

                // Show appropriate message based on whether frames were cached or extracted
                const statusMessage = data.cached ?
                    `Loaded ${totalFrames} frames (cached)` :
                    `Extracted ${totalFrames} frames`;
                showStatus(statusMessage, 'success');

                // Load existing rectangles for this video
                loadExistingRectangles();
            } catch (error) {
                showStatus('Error extracting frames: ' + error.message, 'error');
            }
        }

        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            const ms = Math.floor((seconds % 1) * 100);
            return `${minutes}:${secs.toString().padStart(2, '0')}.${ms.toString().padStart(2, '0')}`;
        }

        function createTimeline() {
            const container = document.getElementById('timelineFrames');
            container.innerHTML = '';

            for (let i = 0; i < totalFrames; i += Math.max(1, Math.floor(totalFrames / 50))) {
                const frameDiv = document.createElement('div');
                frameDiv.className = 'timeline-frame';
                frameDiv.onclick = () => showFrame(i);

                const img = document.createElement('img');
                img.src = `/get_frame/${currentVideo}/${i}`;
                img.alt = `Frame ${i}`;

                // Calculate time for this frame
                const timeInSeconds = i / videoFPS;
                const timeDisplay = document.createElement('div');
                timeDisplay.className = 'time-display';
                timeDisplay.textContent = formatTime(timeInSeconds);

                frameDiv.appendChild(img);
                frameDiv.appendChild(timeDisplay);
                container.appendChild(frameDiv);
            }
        }

        function showFrame(frameIndex) {
            console.log(`Showing frame ${frameIndex} of ${totalFrames}`);
            console.log(`Current rectangles data:`, frameRectangles);

            currentFrameIndex = frameIndex;

            const img = document.getElementById('frameImage');
            const frameUrl = `/get_frame/${currentVideo}/${frameIndex}`;
            console.log(`Loading frame from: ${frameUrl}`);
            img.src = frameUrl;

            // Add error handler for the image
            img.onerror = function () {
                console.error(`Failed to load frame ${frameIndex}`);
                showStatus(`Failed to load frame ${frameIndex + 1}`, 'error');
            };

            img.onload = function () {
                console.log(`Successfully loaded frame ${frameIndex}`);
                // Recalculate image scale when new frame loads
                imageScale = calculateImageScale();
                updateFrameSizeDisplay();
            };

            document.querySelectorAll('.timeline-frame').forEach((frame, index) => {
                const actualIndex = index * Math.max(1, Math.floor(totalFrames / 50));
                frame.classList.toggle('selected', actualIndex === frameIndex);
            });

            const frameInfo = document.getElementById('frameInfo');
            const currentRects = frameRectangles[currentFrameIndex] || [];
            const totalRects = Object.values(frameRectangles).reduce((sum, rects) => sum + rects.length, 0);
            frameInfo.textContent = `Frame ${frameIndex + 1}/${totalFrames} | Current: ${currentRects.length} | Total: ${totalRects}`;

            console.log(`Frame ${frameIndex} has ${currentRects.length} rectangles:`, currentRects);

            setupDrawing();
            updateRectangles();
        }

        function updateFrameSizeDisplay() {
            const frameDisplay = document.getElementById('frameDisplay');
            const frameImage = document.getElementById('frameImage');
            const frameSizeInfo = document.getElementById('frameSizeInfo');
            
            if (!frameSizeInfo) return;
            
            const containerRect = frameDisplay.getBoundingClientRect();
            const containerWidth = Math.round(containerRect.width);
            const containerHeight = Math.round(containerRect.height);
            
            if (frameImage.naturalWidth && frameImage.naturalHeight) {
                const scale = calculateImageScale();
                const displayedWidth = Math.round(scale.displayedWidth);
                const displayedHeight = Math.round(scale.displayedHeight);
                
                frameSizeInfo.textContent = `Container: ${containerWidth}×${containerHeight} | Image: ${displayedWidth}×${displayedHeight} | Original: ${frameImage.naturalWidth}×${frameImage.naturalHeight}`;
            } else {
                frameSizeInfo.textContent = `Container: ${containerWidth}×${containerHeight}`;
            }
        }

        function calculateImageScale() {
            const frameDisplay = document.getElementById('frameDisplay');
            const frameImage = document.getElementById('frameImage');
            
            if (!frameImage.naturalWidth || !frameImage.naturalHeight) {
                return { x: 1, y: 1, offsetX: 0, offsetY: 0 };
            }
            
            const containerRect = frameDisplay.getBoundingClientRect();
            const imageAspect = frameImage.naturalWidth / frameImage.naturalHeight;
            const containerAspect = containerRect.width / containerRect.height;
            
            let displayedWidth, displayedHeight, offsetX, offsetY;
            
            if (imageAspect > containerAspect) {
                // Image is wider, limited by container width
                displayedWidth = containerRect.width;
                displayedHeight = containerRect.width / imageAspect;
                offsetX = 0;
                offsetY = (containerRect.height - displayedHeight) / 2;
            } else {
                // Image is taller, limited by container height  
                displayedWidth = containerRect.height * imageAspect;
                displayedHeight = containerRect.height;
                offsetX = (containerRect.width - displayedWidth) / 2;
                offsetY = 0;
            }
            
            return {
                x: frameImage.naturalWidth / displayedWidth,
                y: frameImage.naturalHeight / displayedHeight,
                offsetX: offsetX,
                offsetY: offsetY,
                displayedWidth: displayedWidth,
                displayedHeight: displayedHeight
            };
        }

        function setupDrawing() {
            const frameDisplay = document.getElementById('frameDisplay');
            
            // Set up ResizeObserver to monitor frame container size changes
            if (window.ResizeObserver) {
                const resizeObserver = new ResizeObserver((entries) => {
                    for (let entry of entries) {
                        // Update image scale and size display when container is resized
                        imageScale = calculateImageScale();
                        updateFrameSizeDisplay();
                        updateRectangles(); // Reposition rectangles with new scale
                    }
                });
                resizeObserver.observe(frameDisplay);
            }

            frameDisplay.onmousedown = function (e) {
                if (e.target !== document.getElementById('frameImage')) return;

                // Update image scale calculation
                imageScale = calculateImageScale();

                // Clear selection when clicking on empty area
                selectedRect = null;
                document.querySelectorAll('.rectangle').forEach(r => {
                    r.classList.remove('selected');
                    r.querySelectorAll('.resize-handle').forEach(h => h.remove());
                });

                isDrawing = true;
                const rect = frameDisplay.getBoundingClientRect();
                
                // Adjust coordinates to account for image offset and ensure they're within image bounds
                const rawX = e.clientX - rect.left;
                const rawY = e.clientY - rect.top;
                
                // Only allow drawing within the actual image area
                if (rawX < imageScale.offsetX || rawX > imageScale.offsetX + imageScale.displayedWidth ||
                    rawY < imageScale.offsetY || rawY > imageScale.offsetY + imageScale.displayedHeight) {
                    isDrawing = false;
                    return;
                }
                
                startX = rawX;
                startY = rawY;

                currentRect = document.createElement('div');
                currentRect.className = 'rectangle';
                currentRect.style.left = startX + 'px';
                currentRect.style.top = startY + 'px';
                frameDisplay.appendChild(currentRect);
            };

            frameDisplay.onmousemove = function (e) {
                const rect = frameDisplay.getBoundingClientRect();
                let currentX = e.clientX - rect.left;
                let currentY = e.clientY - rect.top;

                if (isDrawing && currentRect) {
                    // Constrain drawing to image bounds
                    currentX = Math.max(imageScale.offsetX, Math.min(currentX, imageScale.offsetX + imageScale.displayedWidth));
                    currentY = Math.max(imageScale.offsetY, Math.min(currentY, imageScale.offsetY + imageScale.displayedHeight));
                    
                    const width = Math.abs(currentX - startX);
                    const height = Math.abs(currentY - startY);
                    const left = Math.min(startX, currentX);
                    const top = Math.min(startY, currentY);

                    currentRect.style.left = left + 'px';
                    currentRect.style.top = top + 'px';
                    currentRect.style.width = width + 'px';
                    currentRect.style.height = height + 'px';
                } else if (isDragging && selectedRect) {
                    let newX = currentX - dragOffset.x;
                    let newY = currentY - dragOffset.y;
                    
                    // Constrain dragging to image bounds
                    const rectWidth = parseInt(selectedRect.element.style.width);
                    const rectHeight = parseInt(selectedRect.element.style.height);
                    
                    newX = Math.max(imageScale.offsetX, Math.min(newX, imageScale.offsetX + imageScale.displayedWidth - rectWidth));
                    newY = Math.max(imageScale.offsetY, Math.min(newY, imageScale.offsetY + imageScale.displayedHeight - rectHeight));

                    selectedRect.element.style.left = newX + 'px';
                    selectedRect.element.style.top = newY + 'px';
                } else if (isResizing && selectedRect) {
                    handleResize(currentX, currentY);
                }
            };

            frameDisplay.onmouseup = function (e) {
                if (isDrawing && currentRect) {
                    isDrawing = false;

                    const rectStyle = currentRect.style;
                    const x = parseInt(rectStyle.left);
                    const y = parseInt(rectStyle.top);
                    const width = parseInt(rectStyle.width);
                    const height = parseInt(rectStyle.height);

                    if (width > 10 && height > 10) {
                        if (!frameRectangles[currentFrameIndex]) {
                            frameRectangles[currentFrameIndex] = [];
                        }
                        
                        // Convert display coordinates to image coordinates for storage
                        const imageX = (x - imageScale.offsetX) * imageScale.x;
                        const imageY = (y - imageScale.offsetY) * imageScale.y;
                        const imageWidth = width * imageScale.x;
                        const imageHeight = height * imageScale.y;
                        
                        const newRect = { 
                            x: Math.round(imageX), 
                            y: Math.round(imageY), 
                            width: Math.round(imageWidth), 
                            height: Math.round(imageHeight) 
                        };
                        frameRectangles[currentFrameIndex].push(newRect);
                        console.log(`Added rectangle to frame ${currentFrameIndex}:`, newRect);
                        console.log(`Frame ${currentFrameIndex} now has ${frameRectangles[currentFrameIndex].length} rectangles`);
                        updateFrameInfo();
                    }

                    currentRect = null;
                    updateRectangles();
                } else if (isDragging && selectedRect) {
                    // Update rectangle data
                    const rectStyle = selectedRect.element.style;
                    const displayX = parseInt(rectStyle.left);
                    const displayY = parseInt(rectStyle.top);
                    const displayWidth = parseInt(rectStyle.width);
                    const displayHeight = parseInt(rectStyle.height);
                    
                    // Convert display coordinates to image coordinates for storage
                    const imageX = (displayX - imageScale.offsetX) * imageScale.x;
                    const imageY = (displayY - imageScale.offsetY) * imageScale.y;
                    const imageWidth = displayWidth * imageScale.x;
                    const imageHeight = displayHeight * imageScale.y;
                    
                    const rectData = {
                        x: Math.round(imageX),
                        y: Math.round(imageY),
                        width: Math.round(imageWidth),
                        height: Math.round(imageHeight)
                    };

                    if (selectedRect.rect && !selectedRect.rect.isFromCurrentFrame) {
                        // If adjusting an inherited rectangle, create a new one on current frame
                        if (!frameRectangles[currentFrameIndex]) {
                            frameRectangles[currentFrameIndex] = [];
                        }
                        frameRectangles[currentFrameIndex].push(rectData);
                        showStatus(`Created adjusted rectangle on frame ${currentFrameIndex + 1}`, 'success');
                        updateFrameInfo();
                        updateRectangles();
                    } else {
                        // Update rectangle that was created on current frame
                        const currentRects = getCurrentFrameRectangles();
                        if (currentRects[selectedRect.index]) {
                            Object.assign(currentRects[selectedRect.index], rectData);
                        }
                    }
                    isDragging = false;
                } else if (isResizing && selectedRect) {
                    // Update rectangle data
                    const rectStyle = selectedRect.element.style;
                    const displayX = parseInt(rectStyle.left);
                    const displayY = parseInt(rectStyle.top);
                    const displayWidth = parseInt(rectStyle.width);
                    const displayHeight = parseInt(rectStyle.height);
                    
                    // Convert display coordinates to image coordinates for storage
                    const imageX = (displayX - imageScale.offsetX) * imageScale.x;
                    const imageY = (displayY - imageScale.offsetY) * imageScale.y;
                    const imageWidth = displayWidth * imageScale.x;
                    const imageHeight = displayHeight * imageScale.y;
                    
                    const rectData = {
                        x: Math.round(imageX),
                        y: Math.round(imageY),
                        width: Math.round(imageWidth),
                        height: Math.round(imageHeight)
                    };

                    if (selectedRect.rect && !selectedRect.rect.isFromCurrentFrame) {
                        // If resizing an inherited rectangle, create a new one on current frame
                        if (!frameRectangles[currentFrameIndex]) {
                            frameRectangles[currentFrameIndex] = [];
                        }
                        frameRectangles[currentFrameIndex].push(rectData);
                        showStatus(`Created resized rectangle on frame ${currentFrameIndex + 1}`, 'success');
                        updateFrameInfo();
                        updateRectangles();
                    } else {
                        // Update rectangle that was created on current frame
                        const currentRects = getCurrentFrameRectangles();
                        if (currentRects[selectedRect.index]) {
                            Object.assign(currentRects[selectedRect.index], rectData);
                        }
                    }
                    isResizing = false;
                    resizeHandle = null;
                }
            };
        }

        function handleResize(currentX, currentY) {
            const rect = selectedRect.element;
            const rectData = frameRectangles[currentFrameIndex][selectedRect.index];
            let newX = rectData.x;
            let newY = rectData.y;
            let newWidth = rectData.width;
            let newHeight = rectData.height;

            switch (resizeHandle) {
                case 'nw':
                    newWidth = rectData.x + rectData.width - currentX;
                    newHeight = rectData.y + rectData.height - currentY;
                    newX = currentX;
                    newY = currentY;
                    break;
                case 'ne':
                    newWidth = currentX - rectData.x;
                    newHeight = rectData.y + rectData.height - currentY;
                    newY = currentY;
                    break;
                case 'sw':
                    newWidth = rectData.x + rectData.width - currentX;
                    newHeight = currentY - rectData.y;
                    newX = currentX;
                    break;
                case 'se':
                    newWidth = currentX - rectData.x;
                    newHeight = currentY - rectData.y;
                    break;
                case 'n':
                    newHeight = rectData.y + rectData.height - currentY;
                    newY = currentY;
                    break;
                case 's':
                    newHeight = currentY - rectData.y;
                    break;
                case 'w':
                    newWidth = rectData.x + rectData.width - currentX;
                    newX = currentX;
                    break;
                case 'e':
                    newWidth = currentX - rectData.x;
                    break;
            }

            // Ensure minimum size
            if (newWidth < 20) newWidth = 20;
            if (newHeight < 20) newHeight = 20;

            rect.style.left = newX + 'px';
            rect.style.top = newY + 'px';
            rect.style.width = newWidth + 'px';
            rect.style.height = newHeight + 'px';
        }

        function getActiveRectanglesForFrame(frameIndex) {
            // Get all rectangles that should be active on this frame
            const activeRects = [];
            
            // Look through all frames from 0 to current frame
            for (let i = 0; i <= frameIndex; i++) {
                if (frameRectangles[i]) {
                    frameRectangles[i].forEach((rect, rectIndex) => {
                        const rectId = `${i}_${rectIndex}`;
                        
                        // Check if this rectangle was removed in a later frame
                        let isRemoved = false;
                        for (let j = i + 1; j <= frameIndex; j++) {
                            if (frameRectangles[j]) {
                                // Check if any rectangle in frame j is marked as removing this one
                                const removedRect = frameRectangles[j].find(r => r.removesRect === rectId);
                                if (removedRect) {
                                    isRemoved = true;
                                    break;
                                }
                            }
                        }
                        
                        if (!isRemoved) {
                            activeRects.push({
                                ...rect,
                                originalFrame: i,
                                rectId: rectId,
                                isFromCurrentFrame: i === frameIndex
                            });
                        }
                    });
                }
            }
            
            return activeRects;
        }

        function getAllRectanglesForFrame(frameIndex) {
            // Get all rectangles including deleted ones for display purposes
            const allRects = [];
            
            console.log(`\n=== getAllRectanglesForFrame(${frameIndex}) ===`);
            console.log('Current frameRectangles:', frameRectangles);
            
            // Look through all frames from 0 to current frame
            for (let i = 0; i <= frameIndex; i++) {
                if (frameRectangles[i]) {
                    console.log(`Processing frame ${i} with ${frameRectangles[i].length} items`);
                    frameRectangles[i].forEach((rect, rectIndex) => {
                        if (rect.isRemovalMarker) {
                            console.log(`  Skipping removal marker:`, rect);
                            return; // Skip removal markers
                        }
                        
                        const rectId = `${i}_${rectIndex}`;
                        console.log(`  Processing rectangle ${rectId}:`, rect);
                        
                        // Check if this rectangle was removed in current frame or later
                        let isRemoved = false;
                        for (let j = i; j <= frameIndex; j++) {
                            if (frameRectangles[j]) {
                                // Check if any rectangle in frame j is marked as removing this one
                                const removedRect = frameRectangles[j].find(r => r.removesRect === rectId);
                                if (removedRect) {
                                    console.log(`    Found removal marker for rectId ${rectId} in frame ${j}:`, removedRect);
                                    isRemoved = true;
                                    break;
                                }
                            }
                        }
                        
                        console.log(`    Rectangle ${rectId}: isRemoved=${isRemoved}`);
                        
                        allRects.push({
                            ...rect,
                            originalFrame: i,
                            rectId: rectId,
                            isFromCurrentFrame: i === frameIndex,
                            isDeleted: isRemoved
                        });
                    });
                }
            }
            
            console.log(`=== Returning ${allRects.length} rectangles ===\n`);
            return allRects;
        }

        function updateRectangles() {
            console.log(`updateRectangles called for frame ${currentFrameIndex}`);
            const frameDisplay = document.getElementById('frameDisplay');
            const existingRects = frameDisplay.querySelectorAll('.rectangle');
            console.log(`Removing ${existingRects.length} existing rectangle elements`);
            existingRects.forEach(rect => rect.remove());

            // Update image scale for current display
            imageScale = calculateImageScale();
            updateFrameSizeDisplay();

            // Get all rectangles including deleted ones for current frame
            const allRects = getAllRectanglesForFrame(currentFrameIndex);
            console.log(`Drawing ${allRects.length} rectangles for frame ${currentFrameIndex}:`, allRects);
            
            allRects.forEach((rect, index) => {
                const rectDiv = document.createElement('div');
                
                // Style based on rectangle state
                if (rect.isDeleted) {
                    rectDiv.className = 'rectangle deleted-rectangle';
                } else if (rect.isFromCurrentFrame) {
                    rectDiv.className = 'rectangle';
                } else {
                    rectDiv.className = 'rectangle inherited-rectangle';
                }
                
                // Convert image coordinates to display coordinates
                const displayX = (rect.x / imageScale.x) + imageScale.offsetX;
                const displayY = (rect.y / imageScale.y) + imageScale.offsetY;
                const displayWidth = rect.width / imageScale.x;
                const displayHeight = rect.height / imageScale.y;
                
                rectDiv.style.left = Math.round(displayX) + 'px';
                rectDiv.style.top = Math.round(displayY) + 'px';
                rectDiv.style.width = Math.round(displayWidth) + 'px';
                rectDiv.style.height = Math.round(displayHeight) + 'px';
                rectDiv.dataset.index = index;
                rectDiv.dataset.rectId = rect.rectId;
                rectDiv.dataset.originalFrame = rect.originalFrame;

                // Add click handler for selection/deletion (only for non-deleted rectangles)
                if (!rect.isDeleted) {
                    rectDiv.onclick = (e) => {
                        e.stopPropagation();
                        if (e.shiftKey) {
                            // Shift+click to remove - this marks rectangle as removed from this frame forward
                            removeRectangleFromCurrentFrame(rect.rectId);
                        } else {
                            // Regular click to select
                            selectRectangle(rectDiv, index, rect);
                        }
                    };

                    // Add drag functionality
                    rectDiv.onmousedown = (e) => {
                        if (e.target === rectDiv) {
                            startDragging(e, rectDiv, index, rect);
                        }
                    };
                } else {
                    // Deleted rectangles are not selectable or draggable
                    rectDiv.style.pointerEvents = 'none';
                    actionBtn.style.pointerEvents = 'auto'; // But the undelete button still works
                }

                // Add delete/undelete button
                const actionBtn = document.createElement('div');
                
                if (rect.isDeleted) {
                    // Show undelete button for deleted rectangles
                    actionBtn.className = 'rectangle-undelete';
                    actionBtn.textContent = '↺';
                    actionBtn.title = 'Restore rectangle';
                    actionBtn.onclick = (e) => {
                        e.stopPropagation();
                        handleRectangleUndelete(rect, index);
                    };
                } else {
                    // Show delete button for active rectangles
                    actionBtn.className = rect.isFromCurrentFrame ? 'rectangle-delete' : 'rectangle-delete inherited';
                    actionBtn.textContent = '×';
                    actionBtn.title = rect.isFromCurrentFrame ? 'Delete rectangle' : 'Remove from this frame forward';
                    actionBtn.onclick = (e) => {
                        e.stopPropagation();
                        handleRectangleDelete(rect, index);
                    };
                }

                rectDiv.appendChild(actionBtn);
                frameDisplay.appendChild(rectDiv);
            });
        }
        
        function handleRectangleDelete(rect, index) {
            if (rect.isFromCurrentFrame) {
                // Rectangle was created on current frame - delete it entirely
                const currentRects = getCurrentFrameRectangles();
                const actualIndex = currentRects.findIndex(r => 
                    r.x === rect.x && r.y === rect.y && r.width === rect.width && r.height === rect.height
                );
                
                if (actualIndex !== -1) {
                    currentRects.splice(actualIndex, 1);
                    if (currentRects.length === 0) {
                        delete frameRectangles[currentFrameIndex];
                    }
                    showToast(`Rectangle deleted from frame ${currentFrameIndex + 1}`, 'success', 2000);
                }
            } else {
                // Rectangle is inherited - mark for removal but keep as ghost
                removeRectangleFromCurrentFrame(rect.rectId);
                showToast(`Rectangle marked for removal from frame ${currentFrameIndex + 1} forward`, 'warning', 3000);
            }
            
            updateFrameInfo();
            updateRectangles();
        }

        function handleRectangleUndelete(rect, index) {
            // Remove the removal marker for this rectangle
            if (frameRectangles[currentFrameIndex]) {
                const removalMarkerIndex = frameRectangles[currentFrameIndex].findIndex(r => 
                    r.removesRect === rect.rectId && r.isRemovalMarker
                );
                
                if (removalMarkerIndex !== -1) {
                    frameRectangles[currentFrameIndex].splice(removalMarkerIndex, 1);
                    if (frameRectangles[currentFrameIndex].length === 0) {
                        delete frameRectangles[currentFrameIndex];
                    }
                    showToast(`Rectangle restored from frame ${currentFrameIndex + 1} forward`, 'success', 2000);
                    
                    updateFrameInfo();
                    updateRectangles();
                }
            }
        }

        function removeRectangleFromCurrentFrame(rectId) {
            console.log(`Adding removal marker for rectId: ${rectId} on frame ${currentFrameIndex}`);
            // Add a removal marker to current frame
            if (!frameRectangles[currentFrameIndex]) {
                frameRectangles[currentFrameIndex] = [];
            }
            
            // Add a special rectangle that marks the removal
            frameRectangles[currentFrameIndex].push({
                removesRect: rectId,
                isRemovalMarker: true
            });
            console.log(`Current frameRectangles[${currentFrameIndex}]:`, frameRectangles[currentFrameIndex]);
        }

        function getCurrentFrameRectangles() {
            // Get only rectangles that were actually created on current frame (not inherited ones)
            const currentRects = frameRectangles[currentFrameIndex] || [];
            return currentRects.filter(rect => !rect.isRemovalMarker);
        }

        function selectRectangle(rectDiv, index, rect) {
            // Clear previous selection
            document.querySelectorAll('.rectangle').forEach(r => {
                r.classList.remove('selected');
                r.querySelectorAll('.resize-handle').forEach(h => h.remove());
            });

            // Select new rectangle
            rectDiv.classList.add('selected');
            selectedRect = { element: rectDiv, index: index, rect: rect };

            // Add resize handles
            addResizeHandles(rectDiv, index);
        }

        function addResizeHandles(rectDiv, index) {
            const handles = ['nw', 'ne', 'sw', 'se', 'n', 's', 'w', 'e'];

            handles.forEach(direction => {
                const handle = document.createElement('div');
                handle.className = `resize-handle ${direction}`;
                handle.onmousedown = (e) => {
                    e.stopPropagation();
                    startResizing(e, direction, index);
                };
                rectDiv.appendChild(handle);
            });
        }

        function updateFrameInfo() {
            const frameInfo = document.getElementById('frameInfo');
            const activeRects = getActiveRectanglesForFrame(currentFrameIndex);
            const currentFrameRects = getCurrentFrameRectangles();
            const totalActiveRects = Object.keys(frameRectangles).reduce((sum, frameIndex) => {
                return sum + getActiveRectanglesForFrame(parseInt(frameIndex)).length;
            }, 0);
            frameInfo.textContent = `Frame ${currentFrameIndex + 1}/${totalFrames} | Active: ${activeRects.length} | Current Frame: ${currentFrameRects.length} | Total Active: ${Math.floor(totalActiveRects / Object.keys(frameRectangles).length)}`;
        }

        function startDragging(e, rectDiv, index, rect) {
            isDragging = true;
            const frameRect = frameDisplay.getBoundingClientRect();
            const rectStyle = rectDiv.getBoundingClientRect();

            dragOffset.x = e.clientX - rectStyle.left;
            dragOffset.y = e.clientY - rectStyle.top;

            selectRectangle(rectDiv, index, rect);
        }

        function startResizing(e, direction, index) {
            isResizing = true;
            resizeHandle = direction;
            selectedRect.index = index;

            const rect = frameDisplay.getBoundingClientRect();
            startX = e.clientX - rect.left;
            startY = e.clientY - rect.top;
        }

        function clearRectangles() {
            console.log(`Clearing rectangles for frame ${currentFrameIndex}`);
            if (frameRectangles[currentFrameIndex]) {
                console.log(`Removed ${frameRectangles[currentFrameIndex].length} rectangles from frame ${currentFrameIndex}`);
                delete frameRectangles[currentFrameIndex];
            }

            selectedRect = null;
            updateFrameInfo();
            updateRectangles();
        }


        async function loadExistingRectangles() {
            if (!currentVideo) {
                console.log('No current video to load rectangles for');
                return;
            }

            try {
                console.log(`Loading existing rectangles for ${currentVideo}`);
                const response = await fetch(`/load_rectangles/${currentVideo}`);
                const data = await response.json();

                if (data.success && data.frame_rectangles && Object.keys(data.frame_rectangles).length > 0) {
                    // Merge with existing rectangles (in case user already added some)
                    frameRectangles = { ...frameRectangles, ...data.frame_rectangles };

                    console.log(`Loaded ${data.total_rectangles} rectangles across ${data.total_frames} frames`);
                    showStatus(`Loaded ${data.total_rectangles} existing rectangles from ${data.filename}`, 'success');

                    // Update the display
                    updateFrameInfo();
                    updateRectangles();
                } else {
                    console.log('No existing rectangle data found for this video');
                }
            } catch (error) {
                console.error('Error loading existing rectangles:', error);
                // Don't show error to user as this is optional functionality
            }
        }

        function debugRectangleState() {
            console.log('=== Rectangle State Debug ===');
            console.log('Current frame:', currentFrameIndex);
            console.log('All frame rectangles:', frameRectangles);
            console.log('Current frame rectangles:', frameRectangles[currentFrameIndex] || []);
            console.log('Previous frame rectangles:', frameRectangles[currentFrameIndex - 1] || []);
            console.log('Total rectangles across all frames:', Object.values(frameRectangles).reduce((sum, rects) => sum + rects.length, 0));
            console.log('============================');
        }

        async function saveRectangles() {
            // Check if any frame has rectangles
            const hasRectangles = Object.keys(frameRectangles).length > 0;
            if (!hasRectangles) {
                showStatus('No rectangles to save', 'error');
                return;
            }

            showToast('Saving rectangle data...', 'info', 2000);

            // Filter out removal markers - only send actual rectangles with coordinates
            const filteredFrameRectangles = {};
            for (const [frameIndex, rectangles] of Object.entries(frameRectangles)) {
                const actualRectangles = rectangles.filter(rect => 
                    !rect.isRemovalMarker && 
                    rect.hasOwnProperty('x') && 
                    rect.hasOwnProperty('y') && 
                    rect.hasOwnProperty('width') && 
                    rect.hasOwnProperty('height')
                );
                if (actualRectangles.length > 0) {
                    filteredFrameRectangles[frameIndex] = actualRectangles;
                }
            }

            try {
                const response = await fetch('/save_rectangles', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        video_name: currentVideo,
                        all_frame_rectangles: filteredFrameRectangles,
                        timestamp: new Date().toISOString()
                    })
                });

                const result = await response.json();
                if (result.error) {
                    showStatus(`Save error: ${result.error}`, 'error');
                } else {
                    const downloadUrl = `/download_rectangles/${result.filename}`;
                    // Create toast with download link
                    const downloadMessage = `Saved ${result.total_rectangles} rectangles across ${result.total_frames} frames. <a href="${downloadUrl}" download style="color: #52b788; text-decoration: underline; font-weight: bold;">Download ${result.filename}</a>`;
                    showToastWithHTML(downloadMessage, 'success', 8000);
                }
            } catch (error) {
                showStatus('Error saving rectangles: ' + error.message, 'error');
            }
        }

        let exportAbortController = null;

        function showExportModal() {
            document.getElementById('exportModal').style.display = 'flex';
            resetExportModal();
        }

        function hideExportModal() {
            document.getElementById('exportModal').style.display = 'none';
        }

        function resetExportModal() {
            // Reset all steps to pending
            ['step1', 'step2', 'step3', 'step4'].forEach(stepId => {
                const step = document.getElementById(stepId);
                step.className = 'export-step pending';
                step.querySelector('.step-status').textContent = 'pending';
                step.querySelector('.step-icon').textContent = '⏳';
            });

            // Reset details
            document.getElementById('framesCount').textContent = '-';
            document.getElementById('rectanglesCount').textContent = '-';
            document.getElementById('audioStatus').textContent = 'Checking...';
            document.getElementById('progressText').textContent = 'Starting...';
            document.getElementById('progressBarFill').style.width = '0%';
            document.getElementById('cancelExport').disabled = false;
        }

        function updateExportStep(stepId, status, text = null) {
            const step = document.getElementById(stepId);
            step.className = `export-step ${status}`;
            
            const statusElement = step.querySelector('.step-status');
            const iconElement = step.querySelector('.step-icon');
            
            if (status === 'active') {
                statusElement.textContent = 'running';
                iconElement.textContent = '🔄';
            } else if (status === 'completed') {
                statusElement.textContent = 'done';
                iconElement.textContent = '✅';
            } else if (status === 'error') {
                statusElement.textContent = 'error';
                iconElement.textContent = '❌';
            }
            
            if (text) {
                step.querySelector('.step-text').textContent = text;
            }
        }

        function updateExportProgress(percent, text) {
            document.getElementById('progressBarFill').style.width = percent + '%';
            document.getElementById('progressText').textContent = text;
        }

        function updateExportDetails(frameCount, rectCount, audioStatus) {
            if (frameCount !== undefined) {
                document.getElementById('framesCount').textContent = frameCount;
            }
            if (rectCount !== undefined) {
                document.getElementById('rectanglesCount').textContent = rectCount;
            }
            if (audioStatus !== undefined) {
                document.getElementById('audioStatus').textContent = audioStatus;
            }
        }

        function cancelExport() {
            if (exportAbortController) {
                exportAbortController.abort();
            }
            hideExportModal();
            showToast('Export cancelled by user', 'warning');
        }

        async function exportBlurred() {
            // Show the export modal
            showExportModal();
            
            // Step 1: Analyze and build export data
            updateExportStep('step1', 'active');
            updateExportProgress(10, 'Analyzing rectangles...');
            
            const exportFrameRectangles = {};
            let totalRectangles = 0;
            
            // Calculate active rectangles for each frame up to the total frame count
            for (let frameIndex = 0; frameIndex < totalFrames; frameIndex++) {
                const activeRects = getActiveRectanglesForFrame(frameIndex);
                if (activeRects.length > 0) {
                    exportFrameRectangles[frameIndex] = activeRects.map(rect => ({
                        x: rect.x,
                        y: rect.y,
                        width: rect.width,
                        height: rect.height
                    }));
                    totalRectangles += activeRects.length;
                }
            }
            
            const framesWithRects = Object.keys(exportFrameRectangles).length;
            updateExportDetails(framesWithRects, totalRectangles, 'Checking...');
            
            // Check if any frame has rectangles
            if (framesWithRects === 0) {
                updateExportStep('step1', 'error');
                updateExportProgress(0, 'No rectangles found');
                setTimeout(() => {
                    hideExportModal();
                    showToast('No rectangles to blur across any frames', 'error');
                }, 2000);
                return;
            }

            updateExportStep('step1', 'completed');
            updateExportProgress(25, 'Sending export request...');

            try {
                // Create AbortController for cancellation
                exportAbortController = new AbortController();
                
                const response = await fetch('/export_blurred', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        video_name: currentVideo,
                        all_frame_rectangles: exportFrameRectangles,
                        blur_radius: 15  // Default Gaussian blur radius
                    }),
                    signal: exportAbortController.signal
                });

                // Step 2: Processing frames
                updateExportStep('step2', 'active');
                updateExportProgress(50, 'Processing frames with blur...');
                
                // Step 3: Audio handling  
                updateExportStep('step3', 'active');
                updateExportProgress(75, 'Processing audio...');
                
                const result = await response.json();
                
                if (result.error) {
                    updateExportStep('step2', 'error');
                    updateExportStep('step3', 'error');
                    updateExportStep('step4', 'error');
                    updateExportProgress(0, 'Export failed');
                    setTimeout(() => {
                        hideExportModal();
                        showToast(`Export error: ${result.error}`, 'error');
                    }, 2000);
                } else {
                    // Mark steps as completed
                    updateExportStep('step2', 'completed');
                    updateExportStep('step3', 'completed', 'Audio track copied');
                    updateExportStep('step4', 'active');
                    updateExportProgress(90, 'Finalizing export...');
                    
                    // Update audio status based on result
                    const audioStatus = result.has_audio ? 'Included' : 'Not available';
                    updateExportDetails(undefined, undefined, audioStatus);
                    
                    // Complete
                    setTimeout(() => {
                        updateExportStep('step4', 'completed');
                        updateExportProgress(100, 'Export completed!');
                        document.getElementById('cancelExport').disabled = true;
                        
                        setTimeout(() => {
                            hideExportModal();
                            showToast(`${result.message}`, 'success', 8000);
                        }, 2000);
                    }, 500);
                }
            } catch (error) {
                if (error.name === 'AbortError') {
                    // Export was cancelled
                    return;
                }
                
                updateExportStep('step1', 'error');
                updateExportStep('step2', 'error');
                updateExportStep('step3', 'error');
                updateExportStep('step4', 'error');
                updateExportProgress(0, 'Export failed');
                
                setTimeout(() => {
                    hideExportModal();
                    showToast('Error exporting: ' + error.message, 'error');
                }, 2000);
            }
        }

        function showToast(message, type = 'success', duration = 5000) {
            const container = document.getElementById('toastContainer');
            
            // Create toast element
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            
            // Get appropriate icon
            let icon = '✓';
            if (type === 'error') icon = '✕';
            else if (type === 'warning') icon = '⚠';
            else if (type === 'info') icon = 'ℹ';
            
            // Build toast HTML
            toast.innerHTML = `
                <span class="toast-icon">${icon}</span>
                <div class="toast-message">${message}</div>
                <span class="toast-close" onclick="removeToast(this.parentElement)">×</span>
            `;
            
            // Add to container
            container.appendChild(toast);
            
            // Trigger animation
            setTimeout(() => {
                toast.classList.add('show');
            }, 10);
            
            // Auto remove after duration
            setTimeout(() => {
                removeToast(toast);
            }, duration);
            
            return toast;
        }
        
        function showToastWithHTML(htmlMessage, type = 'success', duration = 5000) {
            const container = document.getElementById('toastContainer');
            
            // Create toast element
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            
            // Get appropriate icon
            let icon = '✓';
            if (type === 'error') icon = '✕';
            else if (type === 'warning') icon = '⚠';
            else if (type === 'info') icon = 'ℹ';
            
            // Build toast HTML with raw HTML message
            toast.innerHTML = `
                <span class="toast-icon">${icon}</span>
                <div class="toast-message">${htmlMessage}</div>
                <span class="toast-close" onclick="removeToast(this.parentElement)">×</span>
            `;
            
            // Add to container
            container.appendChild(toast);
            
            // Trigger animation
            setTimeout(() => {
                toast.classList.add('show');
            }, 10);
            
            // Auto remove after duration
            setTimeout(() => {
                removeToast(toast);
            }, duration);
            
            return toast;
        }

        function removeToast(toast) {
            if (!toast || !toast.parentElement) return;
            
            toast.classList.remove('show');
            setTimeout(() => {
                if (toast.parentElement) {
                    toast.parentElement.removeChild(toast);
                }
            }, 300);
        }
        
        // Legacy function for backward compatibility
        function showStatus(message, type) {
            showToast(message, type);
        }

        async function autoLoadFirstVideo() {
            try {
                const response = await fetch('/get_first_video');

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();

                if (data.video) {
                    const select = document.getElementById('videoSelect');
                    select.value = data.video;
                    currentVideo = data.video;

                    showToast('Auto-loading video...', 'info', 2000);

                    // First get video info to get FPS
                    const videoInfoResponse = await fetch(`/get_video_info/${currentVideo}`);
                    const videoInfo = await videoInfoResponse.json();
                    videoFPS = videoInfo.fps || 30; // Use actual FPS or default to 30

                    const extractResponse = await fetch(`/extract_frames/${currentVideo}`);

                    if (!extractResponse.ok) {
                        throw new Error(`Failed to extract frames: HTTP ${extractResponse.status}`);
                    }

                    const extractData = await extractResponse.json();

                    if (extractData.error) {
                        throw new Error(extractData.error);
                    }

                    totalFrames = extractData.total;

                    createTimeline();
                    showFrame(0);

                    document.getElementById('currentFrame').style.display = 'block';
                    document.getElementById('timeline').style.display = 'block';

                    // Initialize frame size
                    setFrameSize('medium');

                    // Show appropriate message based on whether frames were cached or extracted
                    const statusMessage = extractData.cached ?
                        `Auto-loaded ${currentVideo} with ${totalFrames} frames (cached)` :
                        `Auto-loaded ${currentVideo} with ${totalFrames} frames (extracted)`;
                    showStatus(statusMessage, 'success');

                    // Load existing rectangles for this video
                    loadExistingRectangles();
                } else {
                    console.log('No video found in data folder');
                }
            } catch (error) {
                console.error('Auto-load error:', error);
                showStatus('No video found to auto-load. Please add a video to the data folder.', 'error');
            }
        }

        function setFrameSize(size) {
            const frameDisplay = document.getElementById('frameDisplay');
            const sizeInfo = document.getElementById('sizeInfo');
            const sizeSlider = document.getElementById('sizeSlider');

            // Remove active class from all buttons
            document.querySelectorAll('.size-controls button').forEach(btn => btn.classList.remove('active'));

            let width, height;
            switch (size) {
                case 'small':
                    width = '400px';
                    height = '300px';
                    sizeSlider.value = 400;
                    sizeInfo.textContent = '400px';
                    document.getElementById('sizeSmall').classList.add('active');
                    break;
                case 'medium':
                    width = '600px';
                    height = '450px';
                    sizeSlider.value = 600;
                    sizeInfo.textContent = '600px';
                    document.getElementById('sizeMedium').classList.add('active');
                    break;
                case 'large':
                    width = '800px';
                    height = '600px';
                    sizeSlider.value = 800;
                    sizeInfo.textContent = '800px';
                    document.getElementById('sizeLarge').classList.add('active');
                    break;
                case 'fit':
                    width = '90vw';
                    height = '70vh';
                    sizeSlider.value = 1000;
                    sizeInfo.textContent = 'Fit Screen';
                    document.getElementById('sizeFit').classList.add('active');
                    break;
            }

            frameDisplay.style.width = width;
            frameDisplay.style.height = height;
            
            // Update frame size display after setting new size
            setTimeout(() => {
                updateFrameSizeDisplay();
            }, 50);
        }

        function setCustomSize(value) {
            const frameDisplay = document.getElementById('frameDisplay');
            const sizeInfo = document.getElementById('sizeInfo');

            // Remove active class from preset buttons
            document.querySelectorAll('.size-controls button').forEach(btn => btn.classList.remove('active'));

            const width = value + 'px';
            const height = (value * 0.75) + 'px'; // Maintain 4:3 aspect ratio

            frameDisplay.style.width = width;
            frameDisplay.style.height = height;
            sizeInfo.textContent = value + 'px';
            
            // Update frame size display after setting custom size
            setTimeout(() => {
                updateFrameSizeDisplay();
            }, 50);
        }

        function navigateFrame(direction) {
            if (totalFrames === 0) return;

            let newIndex = currentFrameIndex + direction;
            if (newIndex < 0) newIndex = 0;
            if (newIndex >= totalFrames) newIndex = totalFrames - 1;

            if (newIndex !== currentFrameIndex) {
                showFrame(newIndex);
            }
        }

        function getFramesWithChanges() {
            const framesWithChanges = new Set();
            
            // Get all frames that have rectangle data
            const frameNumbers = Object.keys(frameRectangles).map(f => parseInt(f)).sort((a, b) => a - b);
            
            for (let frameNum of frameNumbers) {
                const rects = frameRectangles[frameNum];
                
                // Check for new rectangles (additions)
                const actualRects = rects.filter(r => !r.isRemovalMarker);
                if (actualRects.length > 0) {
                    framesWithChanges.add(frameNum);
                }
                
                // Check for removal markers
                const removals = rects.filter(r => r.isRemovalMarker);
                if (removals.length > 0) {
                    framesWithChanges.add(frameNum);
                }
            }
            
            return Array.from(framesWithChanges).sort((a, b) => a - b);
        }

        function navigateToPreviousChange() {
            if (totalFrames === 0) {
                showStatus('No video loaded', 'error');
                return;
            }
            
            const framesWithChanges = getFramesWithChanges();
            
            if (framesWithChanges.length === 0) {
                showStatus('No rectangle changes found', 'error');
                return;
            }
            
            // Find the previous frame with changes before current frame
            let previousChangeFrame = null;
            for (let i = framesWithChanges.length - 1; i >= 0; i--) {
                const frameNum = framesWithChanges[i];
                if (frameNum < currentFrameIndex) {
                    previousChangeFrame = frameNum;
                    break;
                }
            }
            
            // If no changes found before current frame, wrap to the last change
            if (previousChangeFrame === null) {
                previousChangeFrame = framesWithChanges[framesWithChanges.length - 1];
                if (previousChangeFrame === currentFrameIndex) {
                    // If current frame is the only frame with changes
                    if (framesWithChanges.length === 1) {
                        showStatus('Only one frame has rectangle changes', 'error');
                        return;
                    } else {
                        // Go to the second-to-last frame with changes
                        previousChangeFrame = framesWithChanges[framesWithChanges.length - 2];
                    }
                }
            }
            
            showFrame(previousChangeFrame);
            
            // Show info about what's happening at this frame
            const rects = frameRectangles[previousChangeFrame] || [];
            const additions = rects.filter(r => !r.isRemovalMarker).length;
            const deletions = rects.filter(r => r.isRemovalMarker).length;
            
            let message = `Previous change: Frame ${previousChangeFrame + 1}`;
            if (additions > 0 && deletions > 0) {
                message += ` (${additions} added, ${deletions} deleted)`;
            } else if (additions > 0) {
                message += ` (${additions} rectangle${additions === 1 ? '' : 's'} added)`;
            } else if (deletions > 0) {
                message += ` (${deletions} rectangle${deletions === 1 ? '' : 's'} deleted)`;
            }
            
            showToast(message, 'info', 3000);
        }

        function navigateToNextChange() {
            if (totalFrames === 0) {
                showStatus('No video loaded', 'error');
                return;
            }
            
            const framesWithChanges = getFramesWithChanges();
            
            if (framesWithChanges.length === 0) {
                showStatus('No rectangle changes found', 'error');
                return;
            }
            
            // Find the next frame with changes after current frame
            let nextChangeFrame = null;
            for (let frameNum of framesWithChanges) {
                if (frameNum > currentFrameIndex) {
                    nextChangeFrame = frameNum;
                    break;
                }
            }
            
            // If no changes found after current frame, wrap to the first change
            if (nextChangeFrame === null) {
                nextChangeFrame = framesWithChanges[0];
                if (nextChangeFrame === currentFrameIndex) {
                    // If current frame is the only frame with changes
                    if (framesWithChanges.length === 1) {
                        showStatus('Only one frame has rectangle changes', 'error');
                        return;
                    } else {
                        // Go to the second frame with changes
                        nextChangeFrame = framesWithChanges[1];
                    }
                }
            }
            
            showFrame(nextChangeFrame);
            
            // Show info about what's happening at this frame
            const rects = frameRectangles[nextChangeFrame] || [];
            const additions = rects.filter(r => !r.isRemovalMarker).length;
            const removals = rects.filter(r => r.isRemovalMarker).length;
            
            let changeInfo = [];
            if (additions > 0) changeInfo.push(`${additions} addition${additions > 1 ? 's' : ''}`);
            if (removals > 0) changeInfo.push(`${removals} removal${removals > 1 ? 's' : ''}`);
            
            showStatus(`Frame ${nextChangeFrame + 1}: ${changeInfo.join(', ')}`, 'success');
        }

        document.addEventListener('keydown', function (e) {
            if (e.key === 'ArrowLeft') {
                e.preventDefault();
                navigateFrame(-1);
            } else if (e.key === 'ArrowRight') {
                e.preventDefault();
                navigateFrame(1);
            } else if (e.key === 'd' && e.ctrlKey) {
                e.preventDefault();
                debugRectangleState();
            } else if (e.key === 'n' && e.ctrlKey) {
                e.preventDefault();
                navigateToNextChange();
            } else if (e.key === 'p' && e.ctrlKey) {
                e.preventDefault();
                navigateToPreviousChange();
            }
        });

        loadVideos();

        // Wait a moment for the DOM to be ready
        setTimeout(() => {
            autoLoadFirstVideo();
        }, 500);
    </script>
</body>

</html>